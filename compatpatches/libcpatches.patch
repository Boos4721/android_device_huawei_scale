diff --git libc/bionic/libc_init_common.cpp libc/bionic/libc_init_common.cpp
index 48fd670..883f158 100644
--- libc/bionic/libc_init_common.cpp
+++ libc/bionic/libc_init_common.cpp
@@ -259,6 +259,7 @@ static bool __is_unsafe_environment_variable(const char* name) {
     "LD_ORIGIN_PATH",
     "LD_PRELOAD",
     "LD_PROFILE",
+    "LD_SHIM_LIBS",
     "LD_SHOW_AUXV",
     "LD_USE_LOAD_BIAS",
     "LOCALDOMAIN",
diff --git libc/bionic/pthread_internal.cpp libc/bionic/pthread_internal.cpp
old mode 100644
new mode 100755
index 829194c..fb182a2
--- libc/bionic/pthread_internal.cpp
+++ libc/bionic/pthread_internal.cpp
@@ -123,7 +123,7 @@ pthread_internal_t* __pthread_internal_find(pthread_t thread_id) {
       // TODO: try getting rid of this when Treble lets us keep vendor blobs on an old API level.
       async_safe_format_log(ANDROID_LOG_WARN, "libc", "invalid pthread_t (0) passed to libc");
     } else {
-      async_safe_fatal("invalid pthread_t %p passed to libc", thread);
+      //async_safe_fatal("invalid pthread_t %p passed to libc", thread);
     }
   }
   return nullptr;
diff --git linker/linker.cpp linker/linker.cpp
index 3d371fb..6ecb9eb 100644
--- linker/linker.cpp
+++ linker/linker.cpp
@@ -700,19 +700,23 @@ enum walk_action_result_t : uint32_t {
 };
 
 #ifdef LD_SHIM_LIBS
+static soinfo* find_library(android_namespace_t* ns,
+                           const char* name, int rtld_flags,
+                           const android_dlextinfo* extinfo,
+                           soinfo* needed_by);
+
 // g_ld_all_shim_libs maintains the references to memory as it used
 // in the soinfo structures and in the g_active_shim_libs list.
+
+typedef std::pair<std::string, std::string> ShimDescriptor;
 static std::vector<ShimDescriptor> g_ld_all_shim_libs;
 
 // g_active_shim_libs are all shim libs that are still eligible
 // to be loaded.  We must remove a shim lib from the list before
 // we load the library to avoid recursive loops (load shim libA
 // for libB where libA also links against libB).
-static linked_list_t<const ShimDescriptor> g_active_shim_libs;
 
-// matched_pairs are shim libs that load over their corresponding
-// target libraries/executables, which are DT_NEEDED.
-std::vector<const ShimDescriptor *> matched_pairs;
+static linked_list_t<const ShimDescriptor> g_active_shim_libs;
 
 static void reset_g_active_shim_libs(void) {
   g_active_shim_libs.clear();
@@ -726,11 +730,9 @@ void parse_LD_SHIM_LIBS(const char* path) {
   if (path != nullptr) {
     // We have historically supported ':' as well as ' ' in LD_SHIM_LIBS.
     for (const auto& pair : android::base::Split(path, " :")) {
-      std::vector<std::string> pieces = android::base::Split(pair, "|");
-      if (pieces.size() != 2) continue;
-      char resolved_path[PATH_MAX];
-      if (realpath(pieces[0].c_str(), resolved_path) != nullptr) {
-        auto desc = std::pair<std::string, std::string>(std::string(resolved_path), pieces[1]);
+      size_t pos = pair.find('|');
+      if (pos > 0 && pos < pair.length() - 1) {
+        auto desc = std::pair<std::string, std::string>(pair.substr(0, pos), pair.substr(pos + 1));
         g_ld_all_shim_libs.push_back(desc);
       }
     }
@@ -738,18 +740,26 @@ void parse_LD_SHIM_LIBS(const char* path) {
   reset_g_active_shim_libs();
 }
 
-void shim_matching_pairs(const char *const path) {
+template<typename F>
+static void for_each_matching_shim(const char *const path, F action) {
+  if (path == nullptr) return;
   INFO("Finding shim libs for \"%s\"\n", path);
+  std::vector<const ShimDescriptor *> matched;
 
   g_active_shim_libs.for_each([&](const ShimDescriptor *a_pair) {
     if (a_pair->first == path) {
-      matched_pairs.push_back(a_pair);
+      matched.push_back(a_pair);
     }
   });
 
   g_active_shim_libs.remove_if([&](const ShimDescriptor *a_pair) {
     return a_pair->first == path;
   });
+
+  for (const auto& one_pair : matched) {
+    INFO("Injecting shim lib \"%s\" as needed for %s", one_pair->second.c_str(), path);
+    action(one_pair->second.c_str());
+  }
 }
 #endif
 
@@ -1171,6 +1181,7 @@ const char* fix_dt_needed(const char* dt_needed, const char* sopath __unused) {
 template<typename F>
 static void for_each_dt_needed(const ElfReader& elf_reader, F action) {
 #ifdef LD_SHIM_LIBS
+  for_each_matching_shim(get_executable_path(), action);
   for_each_matching_shim(elf_reader.name(), action);
 #endif
   for (const ElfW(Dyn)* d = elf_reader.dynamic(); d->d_tag != DT_NULL; ++d) {
diff --git linker/linker_main.cpp linker/linker_main.cpp
index 61a0669..9b10305 100644
--- linker/linker_main.cpp
+++ linker/linker_main.cpp
@@ -183,7 +183,7 @@ static void init_linker_info_for_gdb(ElfW(Addr) linker_base, char* linker_path)
 
 extern "C" int __system_properties_init(void);
 
-static const char* get_executable_path() {
+const char* get_executable_path() {
   static std::string executable_path;
   if (executable_path.empty()) {
     char path[PATH_MAX];
@@ -251,6 +251,7 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args) {
   // doesn't cost us anything.
   const char* ldpath_env = nullptr;
   const char* ldpreload_env = nullptr;
+  const char* ldshim_libs_env = nullptr;
   if (!getauxval(AT_SECURE)) {
     ldpath_env = getenv("LD_LIBRARY_PATH");
     if (ldpath_env != nullptr) {
@@ -260,6 +261,7 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args) {
     if (ldpreload_env != nullptr) {
       INFO("[ LD_PRELOAD set to \"%s\" ]", ldpreload_env);
     }
+    ldshim_libs_env = getenv("LD_SHIM_LIBS");
   }
 
   struct stat file_stat;
@@ -337,7 +339,7 @@ static ElfW(Addr) __linker_init_post_relocation(KernelArgumentBlock& args) {
 
 #ifdef LD_SHIM_LIBS
   // Read from TARGET_LD_SHIM_LIBS
-  parse_LD_SHIM_LIBS(LD_SHIM_LIBS);
+  parse_LD_SHIM_LIBS(ldshim_libs_env);
 #endif
 
   somain = si;
diff --git linker/linker_main.h linker/linker_main.h
index 2cf30c2..64e090b 100644
--- linker/linker_main.h
+++ linker/linker_main.h
@@ -73,4 +73,6 @@ bool solist_remove_soinfo(soinfo* si);
 soinfo* solist_get_head();
 soinfo* solist_get_somain();
 
+const char* get_executable_path();
+
 #endif
diff --git linker/linker_soinfo.h linker/linker_soinfo.h
index c2398ad..29b5c2b 100644
--- linker/linker_soinfo.h
+++ linker/linker_soinfo.h
@@ -33,7 +33,6 @@
 
 #include <string>
 
-#include "linker_debug.h"
 #include "linker_namespaces.h"
 
 #define FLAG_LINKED           0x00000001
@@ -344,29 +343,10 @@ struct soinfo {
 // This function is used by dlvsym() to calculate hash of sym_ver
 uint32_t calculate_elf_hash(const char* name);
 
-#ifdef LD_SHIM_LIBS
-typedef std::pair<std::string, std::string> ShimDescriptor;
-extern std::vector<const ShimDescriptor *> matched_pairs;
-void shim_matching_pairs(const char *const path);
-
-template<typename F>
-void for_each_matching_shim(const char *const path, F action) {
-  if (path == nullptr) return;
-  shim_matching_pairs(path);
-  for (const auto& one_pair : matched_pairs) {
-    INFO("Injecting shim lib \"%s\" as needed for %s", one_pair->second.c_str(), path);
-    action(one_pair->second.c_str());
-  }
-}
-#endif
-
 const char* fix_dt_needed(const char* dt_needed, const char* sopath);
 
 template<typename F>
 void for_each_dt_needed(const soinfo* si, F action) {
-#ifdef LD_SHIM_LIBS
-  for_each_matching_shim(si->get_realpath(), action);
-#endif
   for (const ElfW(Dyn)* d = si->dynamic; d->d_tag != DT_NULL; ++d) {
     if (d->d_tag == DT_NEEDED) {
       action(fix_dt_needed(si->get_string(d->d_un.d_val), si->get_realpath()));
